<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Local search :: Documentation</title>
    <link rel="canonical" href="https://www.optapy.org/docs/latest/local-search/local-search.html">
    <meta name="generator" content="Antora 3.0.1">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
<link rel="stylesheet" href="../../../_/css/menu.css"><!-- Adobe Analytics for Red Hat - DPAL (DTM Property Auto-Loader) - part 1/2 -->
<script id="dpal" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
<!-- Google Analytics for kie team: Global site tag (gtag.js) -->
<script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="https://www.optapy.org">
          <img src="../../../_/img/optaPyLogoDarkBackground200px.png" alt="OptaPy logo"/>
        </a>
        <a class="navbar-item" href="https://www.optapy.org">
          Documentation
        </a>
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/optapy">Get Help</a>
        <div class="navbar-item">
          <a class="navbar-item small-item" href="https://github.com/optapy/optapy" title="Follow OptaPy on GitHub"><img src="https://img.shields.io/github/stars/optapy/optapy?style=flat&logo=github" alt="GitHub" /></a>
          <a class="navbar-item small-item" href="https://twitter.com/OptaPlanner" target="_blank" title="Follow OptaPlanner on Twitter"><img alt="T" src="../../../_/img/twitterLogo.png"></a>
          <a class="navbar-item small-item" href="https://www.linkedin.com/showcase/optaplanner" target="_blank" title="Follow OptaPlanner on LinkedIn"><img alt="L" src="../../../_/img/linkedInLogo.png"></a>
          <a class="navbar-item small-item" href="https://www.facebook.com/OptaPlanner" target="_blank" title="Follow OptaPlanner on Facebook"><img alt="F" src="../../../_/img/facebookLogo.png"></a>
          <a class="navbar-item small-item" href="https://www.youtube.com/channel/UCcpkOKpujFlM67D2h0RdaeQ" target="_blank" title="OptaPlanner YouTube channel"><img alt="YT" src="../../../_/img/youtubeLogo.png" style="height: 16px"></a>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">OptaPy User Guide 8.19.0a1</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../planner-introduction/planner-introduction.html">OptaPy Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../quickstart/quickstart.html">Quickstart</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../planner-configuration/planner-configuration.html">OptaPy configuration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../score-calculation/score-calculation.html">Score calculation</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../constraint-streams/constraint-streams.html">Constraint streams score calculation</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../shadow-variable/shadow-variable.html">Shadow variable</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../optimization-algorithms/optimization-algorithms.html">Optimization algorithms</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../move-and-neighborhood-selection/move-and-neighborhood-selection.html">Move and neighborhood selection</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../exhaustive-search/exhaustive-search.html">Exhaustive search</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../construction-heuristics/construction-heuristics.html">Construction heuristics</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="local-search.html">Local search</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../evolutionary-algorithms/evolutionary-algorithms.html">Evolutionary algorithms</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../partitioned-search/partitioned-search.html">Partitioned search</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../repeated-planning/repeated-planning.html">Repeated planning</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../design-patterns/design-patterns.html">Design patterns</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">OptaPy User Guide 8.19.0a1</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">OptaPy User Guide 8.19.0a1</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../planner-introduction/planner-introduction.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">OptaPy User Guide 8.19.0a1</a></li>
    <li><a href="local-search.html">Local search</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/optapy/optapy/edit/main/optapy-docs/src/modules/ROOT/pages/local-search/local-search.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Local search</h1>
<div class="sect1">
<h2 id="localSearchOverview"><a class="anchor" href="#localSearchOverview"></a>1. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Local Search starts from an initial solution and evolves that single solution into a mostly better and better solution.
It uses a single search path of solutions, not a search tree.
At each solution in this path it evaluates a number of moves on the solution and applies the most suitable move to take the step to the next solution.
It does that for a high number of iterations until it&#8217;s terminated (usually because its time has run out).</p>
</div>
<div class="paragraph">
<p>Local Search acts a lot like a human planner: it uses a single search path and moves facts around to find a good feasible solution.
Therefore it&#8217;s pretty natural to implement.</p>
</div>
<div class="paragraph">
<p><strong>Local Search needs to start from an initialized solution</strong>, therefore it&#8217;s usually required to configure a Construction Heuristic phase before it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="localSearchConcepts"><a class="anchor" href="#localSearchConcepts"></a>2. Local search concepts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="localSearchStepByStep"><a class="anchor" href="#localSearchStepByStep"></a>2.1. Step by step</h3>
<div class="paragraph">
<p>A step is the winning <code>Move</code>.
Local Search tries a number of moves on the current solution and picks the best accepted move as the step:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/decideNextStepNQueens04.png" alt="decideNextStepNQueens04">
</div>
<div class="title">Figure 1. Decide the next step at step 0 (four queens example)</div>
</div>
<div class="paragraph">
<p>Because the move <em>B0 to B3</em> has the highest score (<code>-3</code>), it is picked as the next step.
If multiple moves have the same highest score, one is picked randomly, in this case <em>B0 to B3</em>.
Note that <em>C0 to C3</em> (not shown) could also have been picked because it also has the score <code>-3</code>.</p>
</div>
<div class="paragraph">
<p>The step is applied on the solution.
From that new solution, Local Search tries every move again, to decide the next step after that.
It continually does this in a loop, and we get something like this:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/allStepsNQueens04.png" alt="allStepsNQueens04">
</div>
<div class="title">Figure 2. All steps (four queens example)</div>
</div>
<div class="paragraph">
<p>Notice that Local Search doesn&#8217;t use a search tree, but a search path.
The search path is highlighted by the green arrows.
At each step it tries all selected moves, but unless it&#8217;s the step, it doesn&#8217;t investigate that solution further.
This is one of the reasons why Local Search is very scalable.</p>
</div>
<div class="paragraph">
<p>As shown above, Local Search solves the four queens problem by starting with the starting solution and make the following steps sequentially:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>B0 to B3</em></p>
</li>
<li>
<p><em>D0 to D2</em></p>
</li>
<li>
<p><em>A0 to A1</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Turn on <code>DEBUG</code> logging for the <code>optapy</code> logger to show those steps in the log:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">import logging

logging.getLogger('optapy').setLevel(logging.DEBUG)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">INFO  Solving started: time spent (0), best score (-6), environment mode (REPRODUCIBLE), random (JDK with seed 0).
DEBUG     LS step (0), time spent (20), score (-3), new best score (-3), accepted/selected move count (12/12), picked move (Queen-1 {Row-0 -&gt; Row-3}).
DEBUG     LS step (1), time spent (31), score (-1), new best score (-1), accepted/selected move count (12/12), picked move (Queen-3 {Row-0 -&gt; Row-2}).
DEBUG     LS step (2), time spent (40), score (0), new best score (0), accepted/selected move count (12/12), picked move (Queen-0 {Row-0 -&gt; Row-1}).
INFO  Local Search phase (0) ended: time spent (41), best score (0), score calculation speed (5000/sec), step total (3).
INFO  Solving ended: time spent (41), best score (0), score calculation speed (5000/sec), phase total (1), environment mode (REPRODUCIBLE).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that a log message includes the <code>__str__</code> method of the <code>Move</code> implementation which returns for example "<code>Queen-1 {Row-0 &#8594; Row-3}</code>".</p>
</div>
<div class="paragraph">
<p>A naive Local Search configuration solves the four queens problem in three steps, by evaluating only 37 possible solutions (three steps with 12 moves each + one starting solution), which is only a fraction of all 256 possible solutions.
It solves 16 queens in 31 steps, by evaluating only 7441 out of 18446744073709551616 possible solutions.
By using a <a href="../construction-heuristics/construction-heuristics.html#constructionHeuristics" class="xref page">Construction Heuristics</a> phase first, it&#8217;s even a lot more efficient.</p>
</div>
</div>
<div class="sect2">
<h3 id="localSearchConceptsDecideTheNextStep"><a class="anchor" href="#localSearchConceptsDecideTheNextStep"></a>2.2. Decide the next step</h3>
<div class="paragraph">
<p>Local Search decides the next step with the aid of three configurable components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>MoveSelector</code> which selects the possible moves of the current solution. See the chapter <a href="../move-and-neighborhood-selection/move-and-neighborhood-selection.html#moveAndNeighborhoodSelection" class="xref page">move and neighborhood selection</a>.</p>
</li>
<li>
<p>An <code>Acceptor</code> which filters out unacceptable moves.</p>
</li>
<li>
<p>A <code>Forager</code> which gathers accepted moves and picks the next step from them.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The solver phase configuration looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;unionMoveSelector&gt;
      ...
    &lt;/unionMoveSelector&gt;
    &lt;acceptor&gt;
      ...
    &lt;/acceptor&gt;
    &lt;forager&gt;
      ...
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example below, the <code>MoveSelector</code> generated the moves shown with the blue lines, the <code>Acceptor</code> accepted all of them and the <code>Forager</code> picked the move <em>B0 to B3</em>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/decideNextStepNQueens04.png" alt="decideNextStepNQueens04">
</div>
</div>
<div class="paragraph">
<p><a href="../planner-configuration/planner-configuration.html#logging" class="xref page">Turn on <code>trace</code> logging</a> to show the decision making in the log:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">INFO  Solver started: time spent (0), score (-6), new best score (-6), random (JDK with seed 0).
TRACE         Move index (0) not doable, ignoring move (Queen-0 {Row-0 -&gt; Row-0}).
TRACE         Move index (1), score (-4), accepted (true), move (Queen-0 {Row-0 -&gt; Row-1}).
TRACE         Move index (2), score (-4), accepted (true), move (Queen-0 {Row-0 -&gt; Row-2}).
TRACE         Move index (3), score (-4), accepted (true), move (Queen-0 {Row-0 -&gt; Row-3}).
...
TRACE         Move index (6), score (-3), accepted (true), move (Queen-1 {Row-0 -&gt; Row-3}).
...
TRACE         Move index (9), score (-3), accepted (true), move (Queen-2 {Row-0 -&gt; Row-3}).
...
TRACE         Move index (12), score (-4), accepted (true), move (Queen-3 {Row-0 -&gt; Row-3}).
DEBUG     LS step (0), time spent (6), score (-3), new best score (-3), accepted/selected move count (12/12), picked move (Queen-1 {Row-0 -&gt; Row-3}).
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the last solution can degrade (for example in Tabu Search), the <code>Solver</code> remembers the best solution it has encountered through the entire search path.
Each time the current solution is better than the last best solution, the current solution is <a href="../planner-configuration/planner-configuration.html#cloningASolution" class="xref page">cloned</a> and referenced as the new best solution.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/localSearchScoreOverTime.png" alt="localSearchScoreOverTime">
</div>
</div>
</div>
<div class="sect2">
<h3 id="localSearchAcceptor"><a class="anchor" href="#localSearchAcceptor"></a>2.3. Acceptor</h3>
<div class="paragraph">
<p>An <code>Acceptor</code> is used (together with a <code>Forager</code>) to active Tabu Search, Simulated Annealing, Late Acceptance, &#8230;&#8203; For each move it checks whether it is accepted or not.</p>
</div>
<div class="paragraph">
<p>By changing a few lines of configuration, you can easily switch from Tabu Search to Simulated Annealing or Late Acceptance and back.</p>
</div>
<div class="paragraph">
<p>You can implement your own <code>Acceptor</code>, but the built-in acceptors should suffice for most needs.
You can also combine multiple acceptors.</p>
</div>
</div>
<div class="sect2">
<h3 id="localSearchForager"><a class="anchor" href="#localSearchForager"></a>2.4. Forager</h3>
<div class="paragraph">
<p>A <code>Forager</code> gathers all accepted moves and picks the move which is the next step.
Normally it picks the accepted move with the highest score.
If several accepted moves have the highest score, one is picked randomly to break the tie.
Breaking ties randomly leads to better results.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible to disable breaking ties randomly by explicitly setting <code>breakTieRandomly</code> to <code>false</code>, but that&#8217;s almost never a good idea:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If an earlier move is better than a later move with the same score, the score calculator should add an extra softer <a href="../score-calculation/score-calculation.html#scoreLevel" class="xref page">score level</a> to score the first move as slightly better. Don&#8217;t rely on move selection order to enforce that.</p>
</li>
<li>
<p>Random tie breaking does not affect <a href="../planner-configuration/planner-configuration.html#environmentMode" class="xref page">reproducibility</a>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="acceptedCountLimit"><a class="anchor" href="#acceptedCountLimit"></a>2.4.1. Accepted count limit</h4>
<div class="paragraph">
<p>When there are many possible moves, it becomes inefficient to evaluate all of them at every step.
To evaluate only a random subset of all the moves, use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>acceptedCountLimit</code> integer, which specifies how many accepted moves should be evaluated during each step. By default, all accepted moves are evaluated at every step.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;forager&gt;
    &lt;acceptedCountLimit&gt;1000&lt;/acceptedCountLimit&gt;
  &lt;/forager&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unlike the n queens problem, real world problems require the use of <code>acceptedCountLimit</code>.
Start from an <code>acceptedCountLimit</code> that takes a step in less than two seconds. <a href="../planner-configuration/planner-configuration.html#logging" class="xref page">Turn on INFO logging</a> to see the step times.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>With a low <code>acceptedCountLimit</code> (so a fast stepping algorithm), it is recommended to avoid using <code>selectionOrder</code> SHUFFLED because the shuffling generates a random number for every element in the selector, taking up a lot of time, but only a few elements are actually selected.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="localSearchPickEarlyType"><a class="anchor" href="#localSearchPickEarlyType"></a>2.4.2. Pick early type</h4>
<div class="paragraph">
<p>A forager can pick a move early during a step, ignoring subsequent selected moves.
There are three pick early types for Local Search:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEVER</code>: A move is never picked early: all accepted moves are evaluated that the selection allows. This is the default.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;forager&gt;
      &lt;pickEarlyType&gt;NEVER&lt;/pickEarlyType&gt;
    &lt;/forager&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><code>FIRST_BEST_SCORE_IMPROVING</code>: Pick the first accepted move that improves the best score. If none improve the best score, it behaves exactly like the pickEarlyType NEVER.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_BEST_SCORE_IMPROVING&lt;/pickEarlyType&gt;
    &lt;/forager&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><code>FIRST_LAST_STEP_SCORE_IMPROVING</code>: Pick the first accepted move that improves the last step score. If none improve the last step score, it behaves exactly like the pickEarlyType NEVER.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_LAST_STEP_SCORE_IMPROVING&lt;/pickEarlyType&gt;
    &lt;/forager&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hillClimbing"><a class="anchor" href="#hillClimbing"></a>3. Hill climbing (simple local search)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="hillClimbingAlgorithm"><a class="anchor" href="#hillClimbingAlgorithm"></a>3.1. Algorithm description</h3>
<div class="paragraph">
<p>Hill Climbing tries all selected moves and then takes the best move, which is the move which leads to the solution with the highest score.
That best move is called the step move.
From that new solution, it again tries all selected moves and takes the best move and continues like that iteratively.
If multiple selected moves tie for the best move, one of them is randomly chosen as the best move.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/hillClimbingNQueens04.png" alt="hillClimbingNQueens04">
</div>
</div>
<div class="paragraph">
<p>Notice that once a queen has moved, it can be moved again later.
This is a good thing, because in an NP-complete problem it&#8217;s impossible to predict what will be the optimal final value for a planning variable.</p>
</div>
</div>
<div class="sect2">
<h3 id="hillClimbingStuckInLocalOptima"><a class="anchor" href="#hillClimbingStuckInLocalOptima"></a>3.2. Stuck in local optima</h3>
<div class="paragraph">
<p>Hill climbing always takes improving moves.
This may seem like a good thing, but it&#8217;s not: <strong>Hill Climbing can easily get stuck in a local optimum.</strong> This happens when it reaches a solution for which all the moves deteriorate the score.
Even if it picks one of those moves, the next step might go back to the original solution and which case chasing its own tail:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/hillClimbingGetsStuckInLocalOptimaNQueens04.png" alt="hillClimbingGetsStuckInLocalOptimaNQueens04">
</div>
</div>
<div class="paragraph">
<p>Improvements upon Hill Climbing (such as Tabu Search, Simulated Annealing and Late Acceptance) address the problem of being stuck in local optima.
Therefore, it&#8217;s recommended to never use Hill Climbing, unless you&#8217;re absolutely sure there are no local optima in your planning problem.</p>
</div>
</div>
<div class="sect2">
<h3 id="hillClimbingConfigure"><a class="anchor" href="#hillClimbingConfigure"></a>3.3. Configuration</h3>
<div class="paragraph">
<p>Simplest configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;localSearchType&gt;HILL_CLIMBING&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Advanced configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;acceptorType&gt;HILL_CLIMBING&lt;/acceptorType&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tabuSearch"><a class="anchor" href="#tabuSearch"></a>4. Tabu search</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="tabuSearchAlgorithm"><a class="anchor" href="#tabuSearchAlgorithm"></a>4.1. Algorithm description</h3>
<div class="paragraph">
<p>Tabu Search is a Local Search that maintains a tabu list to avoid getting stuck in local optima.
The tabu list holds recently used objects that are <em>taboo</em> to use for now.
Moves that involve an object in the tabu list, are not accepted.
The tabu list objects can be anything related to the move, such as the planning entity, planning value, move, solution, &#8230;&#8203;
Here&#8217;s an example with entity tabu for four queens, so the queens are put in the tabu list:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/entityTabuSearch.png" alt="entityTabuSearch">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It&#8217;s called Tabu Search, not Taboo Search.
There is no spelling error.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Scientific paper: <em>Tabu Search - Part 1 and Part 2</em> by Fred Glover (1989 - 1990)</p>
</div>
</div>
<div class="sect2">
<h3 id="tabuSearchConfiguration"><a class="anchor" href="#tabuSearchConfiguration"></a>4.2. Configuration</h3>
<div class="paragraph">
<p>Simplest configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;localSearchType&gt;TABU_SEARCH&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When Tabu Search takes steps it creates one or more tabus.
For a number of steps, it does not accept a move if that move breaks tabu.
That number of steps is the tabu size.
Advanced configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1000&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A Tabu Search acceptor should be combined with a high <code>acceptedCountLimit</code>, such as <code>1000</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>OptaPy implements several tabu types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Planning entity tabu</em> (recommended) makes the planning entities of recent steps tabu. For example, for N queens it makes the recently moved queens tabu. It&#8217;s recommended to start with this tabu type.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To avoid hard coding the tabu size, configure a tabu ratio, relative to the number of entities, for example 2%:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;entityTabuRatio&gt;0.02&lt;/entityTabuRatio&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><em>Planning value tabu</em> makes the planning values of recent steps tabu. For example, for N queens it makes the recently moved to rows tabu.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;valueTabuSize&gt;7&lt;/valueTabuSize&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To avoid hard coding the tabu size, configure a tabu ratio, relative to the number of values, for example 2%:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;valueTabuRatio&gt;0.02&lt;/valueTabuRatio&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><em>Move tabu</em> makes recent steps tabu. It does not accept a move equal to one of those steps.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;moveTabuSize&gt;7&lt;/moveTabuSize&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><em>Undo move tabu </em>makes the undo move of recent steps tabu.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;undoMoveTabuSize&gt;7&lt;/undoMoveTabuSize&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using move tabu and undo move tabu with <a href="../move-and-neighborhood-selection/move-and-neighborhood-selection.html#customMoves" class="xref page">custom moves</a>,
make sure that the planning entities do not include planning variables in their <code>__hash__</code> methods.
Failure to do so results in runtime exceptions being thrown due to the <code>__hash__</code> not being constant,
as the entities have their values changed by the local search algorithm.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes it&#8217;s useful to combine tabu types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
      &lt;valueTabuSize&gt;3&lt;/valueTabuSize&gt;
    &lt;/acceptor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the tabu size is too small, the solver can still get stuck in a local optimum.
On the other hand, if the tabu size is too large, the solver can be inefficient by bouncing off the walls.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="simulatedAnnealing"><a class="anchor" href="#simulatedAnnealing"></a>5. Simulated annealing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="simulatedAnnealingAlgorithm"><a class="anchor" href="#simulatedAnnealingAlgorithm"></a>5.1. Algorithm description</h3>
<div class="paragraph">
<p>Simulated Annealing evaluates only a few moves per step, so it steps quickly.
In the classic implementation, the first accepted move is the winning step.
A move is accepted if it doesn&#8217;t decrease the score or - in case it does decrease the score - it passes a random check.
The chance that a decreasing move passes the random check decreases relative to the size of the score decrement and the time the phase has been running (which is represented as the temperature).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/simulatedAnnealing.png" alt="simulatedAnnealing">
</div>
</div>
<div class="paragraph">
<p>Simulated Annealing does not always pick the move with the highest score, neither does it evaluate many moves per step.
At least at first.
Instead, it gives non improving moves also a chance to be picked, depending on its score and the time gradient of the <code>Termination</code>.
In the end, it gradually turns into Hill Climbing, only accepting improving moves.</p>
</div>
</div>
<div class="sect2">
<h3 id="simulatedAnnealingConfiguration"><a class="anchor" href="#simulatedAnnealingConfiguration"></a>5.2. Configuration</h3>
<div class="paragraph">
<p>Start with a <code>simulatedAnnealingStartingTemperature</code> set to the maximum score delta a single move can cause.
Advanced configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;simulatedAnnealingStartingTemperature&gt;2hard/100soft&lt;/simulatedAnnealingStartingTemperature&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simulated Annealing should use a low <code>acceptedCountLimit</code>.
The classic algorithm uses an <code>acceptedCountLimit</code> of <code>1</code>, but often <code>4</code> performs better.</p>
</div>
<div class="paragraph">
<p>Simulated Annealing can be combined with a tabu acceptor at the same time.
That gives Simulated Annealing salted with a bit of Tabu.
Use a lower tabu size than in a pure Tabu Search configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;5&lt;/entityTabuSize&gt;
      &lt;simulatedAnnealingStartingTemperature&gt;2hard/100soft&lt;/simulatedAnnealingStartingTemperature&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lateAcceptance"><a class="anchor" href="#lateAcceptance"></a>6. Late acceptance</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="lateAcceptanceAlgorithm"><a class="anchor" href="#lateAcceptanceAlgorithm"></a>6.1. Algorithm description</h3>
<div class="paragraph">
<p>Late Acceptance (also known as Late Acceptance Hill Climbing) also evaluates only a few moves per step.
A move is accepted if it does not decrease the score, or if it leads to a score that is at least the late score (which is the winning score of a fixed number of steps ago).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/local-search/lateAcceptance.png" alt="lateAcceptance">
</div>
</div>
<div class="paragraph">
<p>Scientific paper: <a href="http://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR192.pdf">The Late Acceptance Hill-Climbing Heuristic by Edmund K. Burke, Yuri Bykov (2012)</a></p>
</div>
</div>
<div class="sect2">
<h3 id="lateAcceptanceConfiguration"><a class="anchor" href="#lateAcceptanceConfiguration"></a>6.2. Configuration</h3>
<div class="paragraph">
<p>Simplest configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;localSearchType&gt;LATE_ACCEPTANCE&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Late Acceptance accepts any move that has a score which is higher than the best score of a number of steps ago.
That number of steps is the <code>lateAcceptanceSize</code>.
Advanced configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;lateAcceptanceSize&gt;400&lt;/lateAcceptanceSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Late Acceptance should use a low <code>acceptedCountLimit</code>.</p>
</div>
<div class="paragraph">
<p>Late Acceptance can be combined with a tabu acceptor at the same time.
That gives Late Acceptance salted with a bit of Tabu.
Use a lower tabu size than in a pure Tabu Search configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;5&lt;/entityTabuSize&gt;
      &lt;lateAcceptanceSize&gt;400&lt;/lateAcceptanceSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="greatDeluge"><a class="anchor" href="#greatDeluge"></a>7. Great Deluge</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="greatDelugeAlgorithm"><a class="anchor" href="#greatDelugeAlgorithm"></a>7.1. Algorithm Description</h3>
<div class="paragraph">
<p>Great Deluge algorithm is similar to the  <a href="#simulatedAnnealing">Simulated Annealing</a> algorithm, it evaluates only a few moves per steps,
so it steps quickly. The first accepted move is the winning step. A move is accepted only if it is not lower than
the score value (water level) that we are working with. It means Great Deluge is deterministic and opposite
of Simulated Annealing has no randomization in it. The water level is increased after every step either about the fixed value
or by percentual value.
A gradual increase in water level gives Great Deluge more time to escape from local maxima.</p>
</div>
</div>
<div class="sect2">
<h3 id="greatDelugeConfiguration"><a class="anchor" href="#greatDelugeConfiguration"></a>7.2. Configuration</h3>
<div class="paragraph">
<p>Simplest configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;localSearchType&gt;GREAT_DELUGE&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Great Deluge takes as starting water level best score from construction heuristic and uses default rain speed ratio. Advanced configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;greatDelugeWaterLevelIncrementRatio&gt;0.00000005&lt;/greatDelugeWaterLevelIncrementRatio&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>OptaPy implements two water level increment options:</p>
</div>
<div class="paragraph">
<p>If <code>greatDelugeWaterLevelIncrementScore</code> is set, the water level is increased by a constant value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;acceptor&gt;
  &lt;greatDelugeWaterLevelIncrementScore&gt;10&lt;/greatDelugeWaterLevelIncrementScore&gt;
&lt;/acceptor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To avoid hard coding the water level increment, configure a <code>greatDelugeWaterLevelIncrementRatio</code> (recommended) when the water level is increased by percentual value, so there is no need to know the size of the problem or value of a scoring function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;acceptor&gt;
  &lt;greatDelugeWaterLevelIncrementRatio&gt;0.00000005&lt;/greatDelugeWaterLevelIncrementRatio&gt;
&lt;/acceptor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The algorithm takes as starting value the best score from the construction heuristic.
Use the Benchmarker to fine-tune tweak your configuration.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stepCountingHillClimbing"><a class="anchor" href="#stepCountingHillClimbing"></a>8. Step counting hill climbing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="stepCountingHillClimbingAlgorithm"><a class="anchor" href="#stepCountingHillClimbingAlgorithm"></a>8.1. Algorithm description</h3>
<div class="paragraph">
<p>Step Counting Hill Climbing also evaluates only a few moves per step.
For a number of steps, it keeps the step score as a threshold.
A move is accepted if it does not decrease the score, or if it leads to a score that is at least the threshold score.</p>
</div>
<div class="paragraph">
<p>Scientific paper: <a href="https://www.researchgate.net/profile/Sanja_Petrovic2/publication/299593956_A_Step_Counting_Hill_Climbing_Algorithm_applied_to_University_Examination_Timetabling/links/5729d02a08aef7c7e2c4103a/A-Step-Counting-Hill-Climbing-Algorithm-applied-to-University-Examination-Timetabling.pdf">An initial study of a novel Step Counting Hill Climbing heuristic applied to timetabling problems by Yuri Bykov, Sanja Petrovic (2013)</a></p>
</div>
</div>
<div class="sect2">
<h3 id="stepCountingHillClimbingConfiguration"><a class="anchor" href="#stepCountingHillClimbingConfiguration"></a>8.2. Configuration</h3>
<div class="paragraph">
<p>Step Counting Hill Climbing accepts any move that has a score which is higher than a threshold score.
Every number of steps (specified by <code>stepCountingHillClimbingSize</code>), the threshold score is set to the step score.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;stepCountingHillClimbingSize&gt;400&lt;/stepCountingHillClimbingSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Step Counting Hill Climbing should use a low <code>acceptedCountLimit</code>.</p>
</div>
<div class="paragraph">
<p>Step Counting Hill Climbing can be combined with a tabu acceptor at the same time, similar as shown in <a href="#lateAcceptance">the Late Acceptance section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="strategicOscillationAlgorithm"><a class="anchor" href="#strategicOscillationAlgorithm"></a>8.3. Algorithm description</h3>
<div class="paragraph">
<p>Strategic Oscillation is an add-on, which works especially well with <a href="#tabuSearch">Tabu Search</a>.
Instead of picking the accepted move with the highest score, it employs a different mechanism: If there&#8217;s an improving move, it picks it.
If there&#8217;s no improving move however, it prefers moves which improve a softer score level, over moves which break a harder score level less.</p>
</div>
</div>
<div class="sect2">
<h3 id="strategicOscillationConfiguration"><a class="anchor" href="#strategicOscillationConfiguration"></a>8.4. Configuration</h3>
<div class="paragraph">
<p>Configure a <code>finalistPodiumType</code>, for example in a Tabu Search configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1000&lt;/acceptedCountLimit&gt;
      &lt;finalistPodiumType&gt;STRATEGIC_OSCILLATION&lt;/finalistPodiumType&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following <code>finalistPodiumType</code>s are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HIGHEST_SCORE</code> (default): Pick the accepted move with the highest score.</p>
</li>
<li>
<p><code>STRATEGIC_OSCILLATION</code>: Alias for the default strategic oscillation variant.</p>
</li>
<li>
<p><code>STRATEGIC_OSCILLATION_BY_LEVEL</code>: If there is an accepted improving move, pick it. If no such move exists, prefer an accepted move which improves a softer score level over one that doesn&#8217;t (even if it has a better harder score level). A move is improving if it&#8217;s better than the last completed step score.</p>
</li>
<li>
<p><code>STRATEGIC_OSCILLATION_BY_LEVEL_ON_BEST_SCORE</code>: Like <code>STRATEGIC_OSCILLATION_BY_LEVEL</code>, but define improving as better than the best score (instead of the last completed step score).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="variableNeighborhoodDescent"><a class="anchor" href="#variableNeighborhoodDescent"></a>9. Variable neighborhood descent</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="variableNeighborhoodDescentAlgorithm"><a class="anchor" href="#variableNeighborhoodDescentAlgorithm"></a>9.1. Algorithm description</h3>
<div class="paragraph">
<p>Variable Neighborhood Descent iteratively tries multiple move selectors
in original order (depleting each selector entirely before trying the next one),
picking the first improving move (which also resets the iterator back to the first move selector).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Despite that VND has a name that ends with <em>descent</em> (from the research papers),
the implementation will ascend to a higher score (which is a better score).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="variableNeighborhoodDescentConfiguration"><a class="anchor" href="#variableNeighborhoodDescentConfiguration"></a>9.2. Configuration</h3>
<div class="paragraph">
<p>Simplest configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;localSearchType&gt;VARIABLE_NEIGHBORHOOD_DESCENT&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Advanced configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">  &lt;localSearch&gt;
    &lt;unionMoveSelector&gt;
      &lt;selectionOrder&gt;ORIGINAL&lt;/selectionOrder&gt;
      &lt;changeMoveSelector/&gt;
      &lt;swapMoveSelector/&gt;
      ...
    &lt;/unionMoveSelector&gt;
    &lt;acceptor&gt;
      &lt;acceptorType&gt;HILL_CLIMBING&lt;/acceptorType&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_LAST_STEP_SCORE_IMPROVING&lt;/pickEarlyType&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Variable Neighborhood Descent doesn&#8217;t scale well,
but it is useful in some use cases with a very erratic score landscape.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="customTerminationSelectorOrAcceptor"><a class="anchor" href="#customTerminationSelectorOrAcceptor"></a>10. Using a custom <code>Termination</code>, <code>MoveSelector</code>, <code>EntitySelector</code>, <code>ValueSelector</code>, or <code>Acceptor</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Custom <code>Termination</code>, <code>MoveSelector</code>, <code>EntitySelector</code>, <code>ValueSelector</code>, and <code>Acceptor</code> are currently not supported in OptaPy.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>

<!-- Adobe Analytics for Red Hat - DPAL (DTM Property Auto-Loader) - part 2/2 -->
<script type="text/javascript">
    if (("undefined" !== typeof _satellite) && ("function" === typeof _satellite.pageBottom)) {
        _satellite.pageBottom();
    }
</script>  </body>
</html>
