<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>OptaPy configuration :: Documentation</title>
    <link rel="canonical" href="https://www.optapy.org/docs/latest/planner-configuration/planner-configuration.html">
    <meta name="generator" content="Antora 3.0.2">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
<link rel="stylesheet" href="../../../_/css/menu.css"><!-- Adobe Analytics for Red Hat - DPAL (DTM Property Auto-Loader) - part 1/2 -->
<script id="dpal" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
<!-- Google Analytics for kie team: Global site tag (gtag.js) -->
<script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="https://www.optapy.org">
          <img src="../../../_/img/optaPyLogoDarkBackground200px.png" alt="OptaPy logo"/>
        </a>
        <a class="navbar-item" href="https://www.optapy.org">
          Documentation
        </a>
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/optapy">Get Help</a>
        <div class="navbar-item">
          <a class="navbar-item small-item" href="https://github.com/optapy/optapy" title="Follow OptaPy on GitHub"><img src="https://img.shields.io/github/stars/optapy/optapy?style=flat&logo=github" alt="GitHub" /></a>
          <a class="navbar-item small-item" href="https://twitter.com/OptaPlanner" target="_blank" title="Follow OptaPlanner on Twitter"><img alt="T" src="../../../_/img/twitterLogo.png"></a>
          <a class="navbar-item small-item" href="https://www.linkedin.com/showcase/optaplanner" target="_blank" title="Follow OptaPlanner on LinkedIn"><img alt="L" src="../../../_/img/linkedInLogo.png"></a>
          <a class="navbar-item small-item" href="https://www.facebook.com/OptaPlanner" target="_blank" title="Follow OptaPlanner on Facebook"><img alt="F" src="../../../_/img/facebookLogo.png"></a>
          <a class="navbar-item small-item" href="https://www.youtube.com/channel/UCcpkOKpujFlM67D2h0RdaeQ" target="_blank" title="OptaPlanner YouTube channel"><img alt="YT" src="../../../_/img/youtubeLogo.png" style="height: 16px"></a>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">OptaPy User Guide 8.23.0a0</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../planner-introduction/planner-introduction.html">OptaPy Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../quickstart/quickstart.html">Quickstart</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="planner-configuration.html">OptaPy configuration</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../score-calculation/score-calculation.html">Score calculation</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../constraint-streams/constraint-streams.html">Constraint streams score calculation</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../shadow-variable/shadow-variable.html">Shadow variable</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../optimization-algorithms/optimization-algorithms.html">Optimization algorithms</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../move-and-neighborhood-selection/move-and-neighborhood-selection.html">Move and neighborhood selection</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../exhaustive-search/exhaustive-search.html">Exhaustive search</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../construction-heuristics/construction-heuristics.html">Construction heuristics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../local-search/local-search.html">Local search</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../evolutionary-algorithms/evolutionary-algorithms.html">Evolutionary algorithms</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../partitioned-search/partitioned-search.html">Partitioned search</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../repeated-planning/repeated-planning.html">Repeated planning</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../design-patterns/design-patterns.html">Design patterns</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">OptaPy User Guide 8.23.0a0</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">OptaPy User Guide 8.23.0a0</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../planner-introduction/planner-introduction.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">OptaPy User Guide 8.23.0a0</a></li>
    <li><a href="planner-configuration.html">OptaPy configuration</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/optapy/optapy/edit/main/optapy-docs/src/modules/ROOT/pages/planner-configuration/planner-configuration.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">OptaPy configuration</h1>
<div class="sect1">
<h2 id="optapyConfigurationOverview"><a class="anchor" href="#optapyConfigurationOverview"></a>1. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Solving a planning problem with OptaPy consists of the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Model your planning problem</strong> as a class annotated with the <code>@planning_solution</code> decorator, for example the <code>NQueens</code> class.</p>
</li>
<li>
<p><strong>Configure a <code><strong>Solver</strong></code></strong>, for example a First Fit and Tabu Search solver for any <code>NQueens</code> instance.</p>
</li>
<li>
<p><strong>Load a problem data set</strong> from your data layer, for example a Four Queens instance. That is the planning problem.</p>
</li>
<li>
<p><strong>Solve it</strong> with <code>Solver.solve(problem)</code> which returns the best solution found.</p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/planner-configuration/inputOutputOverview.png" alt="inputOutputOverview">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solverConfiguration"><a class="anchor" href="#solverConfiguration"></a>2. Solver configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="solverConfigurationByXML"><a class="anchor" href="#solverConfigurationByXML"></a>2.1. Solver configuration by XML</h3>
<div class="paragraph">
<p>Build a <code>Solver</code> instance with the <code>SolverFactory</code>.
Create a <code>SolverFactory</code> by passing a <code>SolverConfig</code> to
<code>solver_factory_create</code>.
A <code>SolverConfig</code> can be created from a XML file, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import solver_config_create_from_xml_file
import pathlib

solver_config = solver_config_create_from_xml_file(pathlib.Path('solverConfig.xml'))

solver_factory = solver_factory_create(solver_config)

solver_factory.buildSolver().solve(generate_problem())</code></pre>
</div>
</div>
<div class="paragraph">
<p>A solver configuration XML file looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  &lt;!-- Define the model --&gt;
  &lt;solutionClass&gt;optapy.examples.domain.NQueens&lt;/solutionClass&gt;
  &lt;entityClass&gt;optapy.examples.domain.Queen&lt;/entityClass&gt;

  &lt;!-- Define the score function --&gt;
  &lt;scoreDirectorFactory&gt;
    &lt;constraintProviderClass&gt;optapy.examples.constraints.n_queens_constraints&lt;/constraintProviderClass&gt;
  &lt;/scoreDirectorFactory&gt;

  &lt;!-- Configure the optimization algorithms (optional) --&gt;
  &lt;termination&gt;
    ...
  &lt;/termination&gt;
  &lt;constructionHeuristic&gt;
    ...
  &lt;/constructionHeuristic&gt;
  &lt;localSearch&gt;
    ...
  &lt;/localSearch&gt;
&lt;/solver&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For XML elements that end in "Class" (solutionClass, entityClass, constraintProviderClass, etc.), put "{module}.{name}", where
{module} is the module the class/function was defined in, and
name is the name of the class/function. If the module is
"__main__", put "{name}" instead. For instance, if the below code was in the main module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import constraint_provider, planning_solution
from my.domain import MyEntity

@planning_solution
class MySolution:
    ...

@constraint_provider
def my_constraints(constraint_factory):
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use "my.domain.MyEntity" to refer to "MyEntity", "MySolution" to refer to "MySolution", and "my_constraints" to refer to "my_constraints".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Notice the three parts in it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Define the model.</p>
</li>
<li>
<p>Define the score function.</p>
</li>
<li>
<p>Optionally configure the optimization algorithm(s).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These various parts of a configuration are explained further in this manual.</p>
</div>
<div class="paragraph">
<p><strong>OptaPy makes it relatively easy to switch optimization algorithm(s) just by changing the configuration.</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="solverConfigurationByPythonAPI"><a class="anchor" href="#solverConfigurationByPythonAPI"></a>2.2. Solver configuration by Python API</h3>
<div class="paragraph">
<p>A solver configuration can also be configured with the <code>SolverConfig</code> API.
This is especially useful to change some values dynamically at runtime.
For example, to change the running time based on an environment variable, before building the <code>Solver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">import os
import optapy
import optapy.config
import pathlib

SOLVE_TIME_IN_MINUTES = os.environ['SOLVE_TIME_IN_MINUTES']
termination_config = optapy.config.solver.TerminationConfig() \
    .withMinutesSpentLimit(SOLVE_TIME_IN_MINUTES)

solver_config = solver_config_create_from_xml_file(pathlib.Path('solverConfig.xml')) \
    .withTerminationConfig(termination_config)

solver_factory = solver_factory_create(solver_config)

solver_factory.buildSolver().solve(generate_problem())</code></pre>
</div>
</div>
<div class="paragraph">
<p>Every element in the solver configuration XML is available as a <code>*Config</code> class
or a property on a <code>*Config</code> class in the package <code>optapy.config</code>.
These <code>*Config</code> classes are the Python representation of the XML format.
They build the runtime components and assemble them into an efficient <code>Solver</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To configure a <code>SolverFactory</code> dynamically for each user request,
build a template <code>SolverConfig</code> during initialization
and copy it with the copy constructor for each user request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">termination_config = optapy.config.solver.TerminationConfig()
template = solver_config_create_from_xml_file(pathlib.Path('solverConfig.xml')) \
    .withTerminationConfig(termination_config)

# Called concurrently from different threads
def user_request(..., user_input):
    solver_config = optapy.config.solver.SolverConfig(template) # Copy it
    solver_config.getTerminationConfig().setMinutesSpentLimit(user_input)
    solver_factory = solver_factory_create(solver_config)
    solver = solver_factory.buildSolver();
    ...</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modelAPlanningProblem"><a class="anchor" href="#modelAPlanningProblem"></a>3. Model a planning problem</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="isThisClassAProblemFactOrPlanningEntity"><a class="anchor" href="#isThisClassAProblemFactOrPlanningEntity"></a>3.1. Is this class a problem fact or planning entity?</h3>
<div class="paragraph">
<p>Look at a dataset of your planning problem.
You will recognize domain classes in there, each of which can be categorized as one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An unrelated class: not used by any of the score constraints.
From a planning standpoint, this data is obsolete.</p>
</li>
<li>
<p>A <strong>problem fact</strong> class: used by the score constraints, but does NOT change during planning (as long as the problem stays the same).
For example: <code>Bed</code>, <code>Room</code>, <code>Shift</code>, <code>Employee</code>, <code>Topic</code>, <code>Period</code>, &#8230;&#8203; All the properties of a problem fact class are problem properties.</p>
</li>
<li>
<p>A <strong>planning entity</strong> class: used by the score constraints and changes during planning.
For example: <code>BedDesignation</code>, <code>ShiftAssignment</code>, <code>Exam</code>, &#8230;&#8203; The properties that change during planning are planning variables.
The other properties are problem properties.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ask yourself: <em>What class changes during planning?</em> <em>Which class has variables that I want the <code></em>Solver<em></code> to change for me?</em> That class is a planning entity.
Most use cases have only one planning entity class.
Most use cases also have only one planning variable per planning entity class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="literalblock">
<div class="content">
<pre>In xref:repeated-planning/repeated-planning.adoc#realTimePlanning[real-time planning], even though the problem itself changes, problem facts do not really change during planning, instead they change between planning (because the Solver temporarily stops to apply the problem fact changes).</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To create a good domain model, read the
<a href="../design-patterns/design-patterns.html#domainModelingGuide" class="xref page">domain modeling guide</a>.</p>
</div>
<div class="paragraph">
<p><strong>In OptaPy, all problem facts and planning entities are plain old Python Objects.</strong> Load them from a database, an XML file, a data repository, a REST service, a noSQL cloud; it doesn&#8217;t matter.</p>
</div>
</div>
<div class="sect2">
<h3 id="problemFact"><a class="anchor" href="#problemFact"></a>3.2. Problem fact</h3>
<div class="paragraph">
<p>A problem fact is any Python Object with getters that does not change during planning.
For example in n queens, the columns and rows are problem facts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import problem_fact

@problem_fact
class Column:
    def __init__(self, index):
        self.index = index
    ...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import problem_fact

@problem_fact
class Row:
    def __init__(self, index):
        self.index = index
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>A problem fact can reference other problem facts of course:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import problem_fact

@problem_fact
class Teacher:
    ...

@problem_fact
class Curriculum:
    ...

@problem_fact
class Course:
    code: str
    teacher: Teacher # Other problem fact
    lecture_size: int
    min_working_day_size: int
    curriculum_list: list[Curriculum] # Other problem facts
    student_size: int
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike OptaPlanner, a problem fact class <strong>must</strong> be decorated with <code>@problem_fact</code> to be used in constraints.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Generally, better designed domain classes lead to simpler and more efficient score constraints.
Therefore, when dealing with a messy (denormalized) legacy system, it can sometimes be worthwhile to convert the messy domain model into a OptaPy specific model first.
For example: if your domain model has two <code>Teacher</code> instances for the same teacher that teaches at two different departments, it is harder to write a correct score constraint that constrains a teacher&#8217;s spare time on the original model than on an adjusted model.
Alternatively, you can sometimes also introduce <a href="#cachedProblemFact"><em>a cached problem fact</em></a> to enrich the domain model for planning only.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="planningEntity"><a class="anchor" href="#planningEntity"></a>3.3. Planning entity</h3>
<div class="sect3">
<h4 id="planningEntityDecorator"><a class="anchor" href="#planningEntityDecorator"></a>3.3.1. Planning entity decorator</h4>
<div class="paragraph">
<p>A planning entity is a Python Object that changes during solving, for example a <code>Queen</code> that changes to another row.
A planning problem has multiple planning entities, for example for a single n queens problem, each <code>Queen</code> is a planning entity.
But there is usually only one planning entity class, for example the <code>Queen</code> class.</p>
</div>
<div class="paragraph">
<p>A planning entity class needs to be decorated with the <code>@planning_entity</code> decorator.</p>
</div>
<div class="paragraph">
<p>Each planning entity class has one or more <em>planning variables</em> (which can be <a href="#planningVariable">genuine</a> or <a href="../shadow-variable/shadow-variable.html#shadowVariable" class="xref page">shadows</a>).
It should also have one or more <em>defining</em> properties.
For example in n queens, a <code>Queen</code> is defined by its <code>Column</code> and has a planning variable <code>Row</code>.
This means that a Queen&#8217;s column never changes during solving, while its row does change.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_entity

@planning_entity
class Queen:
    column: Column

    # Planning variables: changes during planning, between score calculations.
    row: Row
    # ... getters and setters</code></pre>
</div>
</div>
<div class="paragraph">
<p>A planning entity class can have multiple planning variables.
For example, a <code>Lecture</code> is defined by its <code>Course</code> and its index in that course (because one course has multiple lectures).
Each <code>Lecture</code> needs to be scheduled into a <code>Period</code> and a <code>Room</code> so it has two planning variables (period and room).
For example: the course Mathematics has eight lectures per week, of which the first lecture is Monday morning at 08:00 in room 212.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_entity

@planning_entity
class Lecture:
    course: Course
    lectureIndexInCourse: int

    # Planning variables: changes during planning, between score calculations.
    period: Period
    room: Room
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solver configuration needs to declare each planning entity class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  ...
  &lt;entityClass&gt;optapy.examples.domain.Queen&lt;/entityClass&gt;
  ...
&lt;/solver&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some uses cases have multiple planning entity classes.
For example: route freight and trains into railway network arcs, where each freight can use multiple trains over its journey and each train can carry multiple freights per arc.
Having multiple planning entity classes directly raises the implementation complexity of your use case.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Do not create unnecessary planning entity classes.</em> This leads to difficult <code>Move</code> implementations and slower score calculation.</p>
</div>
<div class="paragraph">
<p>For example, do not create a planning entity class to hold the total free time of a teacher, which needs to be kept up to date as the <code>Lecture</code> planning entities change.
Instead, calculate the free time in the score constraints (or as a <a href="../shadow-variable/shadow-variable.html#shadowVariable" class="xref page">shadow variable</a>) and put the result per teacher into a logically inserted score object.</p>
</div>
<div class="paragraph">
<p>If historic data needs to be considered too, then create problem fact to hold the total of the historic assignments up to, but <em>not including</em>, the planning window (so that it does not change when a planning entity changes) and let the score constraints take it into account.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Planning entity <code>__hash__(self)</code> implementations must remain constant. Therefore entity <code>__hash__(self)</code> must not depend on any planning variables. Pay special attention when using data structures with auto-generated <code>__hash__(self)</code> as entities, such as Python <code>@dataclass</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="planningEntityDifficulty"><a class="anchor" href="#planningEntityDifficulty"></a>3.3.2. Planning entity difficulty</h4>
<div class="paragraph">
<p>Planning entity difficulty is not yet supported, but will be in a future version.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="planningVariable"><a class="anchor" href="#planningVariable"></a>3.4. Planning variable (genuine)</h3>
<div class="sect3">
<h4 id="planningVariableDecorator"><a class="anchor" href="#planningVariableDecorator"></a>3.4.1. Planning variable decorator</h4>
<div class="paragraph">
<p>A planning variable is a Python property (so a getter and setter) on a planning entity.
It points to a planning value, which changes during planning.
For example, a <code>Queen</code>'s <code>row</code> property is a genuine planning variable.
Note that even though a <code>Queen</code>'s <code>row</code> property changes to another <code>Row</code> during planning, no <code>Row</code> instance itself is changed.
Normally planning variables are genuine, but advanced cases can also have <a href="../shadow-variable/shadow-variable.html#shadowVariable" class="xref page">shadows</a>.</p>
</div>
<div class="paragraph">
<p>A genuine planning variable getter needs to be annotated with the <code>@planning_variable</code> annotation, which needs a non-empty <code>variable_type</code> and <code>value_range_provider_refs</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_entity, planning_variable

@planning_entity
class Queen:
    # ...
    row: Row

    # Alternatively, @planning_variable(Row, ["row_range"])
    @planning_variable(variable_type = Row, value_range_provider_refs = ["row_range"])
    def get_row(self):
        return self.row

    def set_row(self, row):
        self.row = row</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>variable_type</code> property define the type of planning values this planning variable takes. The <code>variable_type</code> does not need to be decorated with <code>@problem_fact</code>; it can be any Python type.
The <code>value_range_provider_refs</code> property defines what are the possible planning values for this planning variable.
It references one or more <code>@ValueRangeProvider</code> <code>id</code>'s.</p>
</div>
</div>
<div class="sect3">
<h4 id="nullablePlanningVariable"><a class="anchor" href="#nullablePlanningVariable"></a>3.4.2. Nullable planning variable</h4>
<div class="paragraph">
<p>By default, an initialized planning variable cannot be <code>None</code>, so an initialized solution will never use <code>None</code> for any of its planning variables.
In an over-constrained use case, this can be counterproductive.
For example: in task assignment with too many tasks for the workforce, we would rather leave low priority tasks unassigned instead of assigning them to an overloaded worker.</p>
</div>
<div class="paragraph">
<p>To allow an initialized planning variable to be <code>None</code>, set <code>nullable</code> to <code>True</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    @planning_variable(..., nullable = True)
    def get_worker(self):
        return self.worker</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Constraint Streams filter out planning entities with a <code>None</code> planning variable by default.
Use <a href="../constraint-streams/constraint-streams.html#constraintStreamsForEach" class="xref page">forEachIncludingNullVars()</a> to avoid such unwanted behaviour.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>OptaPy will automatically add the value <code>None</code> to the value range.
There is no need to add <code>None</code> in a collection provided by a <code>@value_range_provider</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using a nullable planning variable implies that your score calculation is responsible for punishing (or even rewarding) variables with a <code>None</code> value.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Currently <a href="#chainedPlanningVariable">chained</a> planning variables are not compatible with <code>nullable</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="../repeated-planning/repeated-planning.html#repeatedPlanning" class="xref page">Repeated planning</a> (especially <a href="../repeated-planning/repeated-planning.html#realTimePlanning" class="xref page">real-time planning</a>) does not mix well with a nullable planning variable.
Every time the Solver starts or a problem fact change is made, the <a href="../construction-heuristics/construction-heuristics.html#constructionHeuristics" class="xref page">Construction Heuristics</a>
will try to initialize all the <code>None</code> variables again, which can be a huge waste of time.
One way to deal with this is to filter the entity selector of the placer in the construction heuristic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  ...
  &lt;constructionHeuristic&gt;
    &lt;queuedEntityPlacer&gt;
      &lt;entitySelector id="entitySelector1"&gt;
        &lt;filterClass&gt;...&lt;/filterClass&gt;
      &lt;/entitySelector&gt;
    &lt;/queuedEntityPlacer&gt;
    ...
    &lt;changeMoveSelector&gt;
      &lt;entitySelector mimicSelectorRef="entitySelector1" /&gt;
    &lt;/changeMoveSelector&gt;
    ...
  &lt;/constructionHeuristic&gt;
 ...
&lt;/solver&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="whenIsAPlanningVariableInitialized"><a class="anchor" href="#whenIsAPlanningVariableInitialized"></a>3.4.3. When is a planning variable considered initialized?</h4>
<div class="paragraph">
<p>A planning variable is considered initialized if its value is not <code>None</code> or if the variable is <code>nullable</code>.
So a nullable variable is always considered initialized.</p>
</div>
<div class="paragraph">
<p>A planning entity is initialized if all of its planning variables are initialized.</p>
</div>
<div class="paragraph">
<p>A solution is initialized if all of its planning entities are initialized.</p>
</div>
</div>
<div class="sect3">
<h4 id="planningValue"><a class="anchor" href="#planningValue"></a>3.4.4. Planning value</h4>
<div class="paragraph">
<p>A planning value is a possible value for a genuine planning variable.
Usually, a planning value is a problem fact, but it can also be any object, for example an <code>int</code>.
It can even be another planning entity or even an interface implemented by both a planning entity and a problem fact.</p>
</div>
<div class="paragraph">
<p>A planning value range is the set of possible planning values for a planning variable.
This set can be a countable (for example row <code>1</code>, <code>2</code>, <code>3</code> or <code>4</code>) or uncountable (for example any <code>float</code> between <code>0.0</code> and <code>1.0</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="planningValueRangeProvider"><a class="anchor" href="#planningValueRangeProvider"></a>3.4.5. Planning value range provider</h4>
<div class="sect4">
<h5 id="planningValueRangeProviderOverview"><a class="anchor" href="#planningValueRangeProviderOverview"></a>Overview</h5>
<div class="paragraph">
<p>The value range of a planning variable is defined with the <code>@value_range_provider</code> decorator.
A <code>@value_range_provider</code> decorator always has a property <code>range_id</code>, which is referenced by the <code>@planning_variable</code>'s property <code>value_range_provider_refs</code>.</p>
</div>
<div class="paragraph">
<p>This annotation can be located on two types of methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On the Solution: All planning entities share the same value range.</p>
</li>
<li>
<p>On the planning entity: The value range differs per planning entity. This is less common.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A @value_range_provider annotation needs to be on a member in a class with a <code>@planning_solution</code> or a <code>@planning_entity</code> annotation.
It is ignored on parent classes or subclasses without those annotations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The return type of that method can be two types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List</code>: The value range is defined by a list of its possible values.</p>
</li>
<li>
<p><code>ValueRange</code>: The value range is defined by its bounds. This is less common.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="valueRangeProviderOnSolution"><a class="anchor" href="#valueRangeProviderOnSolution"></a><code>ValueRangeProvider</code> on the solution</h5>
<div class="paragraph">
<p>All instances of the same planning entity class share the same set of possible planning values for that planning variable.
This is the most common way to configure a value range.</p>
</div>
<div class="paragraph">
<p>The <code>@planning_solution</code> implementation has method that returns a <code>list</code> (or a <code>ValueRange</code>).
Any value from that <code>list</code> is a possible planning value for this planning variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    @planning_variable(Row, value_range_provider_refs = {"row_range"})
    def get_row(self):
        return self.row</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution, value_range_provider, problem_fact_collection_property

@planning_solution
class NQueens:
    # ...
    @value_range_provider(range_id = "row_range")
    def get_row_list(self):
        return self.row_list</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>That <code>list</code> (or <code>ValueRange</code>) must not contain the value <code>null</code>, not even for a <a href="#nullablePlanningVariable">nullable planning variable</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="valueRangeProviderOnPlanningEntity"><a class="anchor" href="#valueRangeProviderOnPlanningEntity"></a><code>ValueRangeProvider</code> on the Planning Entity</h5>
<div class="paragraph">
<p>Each planning entity has its own value range (a set of possible planning values) for the planning variable.
For example, if a teacher can <strong>never</strong> teach in a room that does not belong to his department, lectures of that teacher can limit their room value range to the rooms of his department.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    @planning_variable(value_range_provider_refs = ["department_room_range"])
    def get_room(self):
        return self.room

    @value_range_provider(range_id = "department_room_range")
    def get_possible_room_list(self):
        return self.course.teacher.department.room_list</code></pre>
</div>
</div>
<div class="paragraph">
<p>Never use this to enforce a soft constraint (or even a hard constraint when the problem might not have a feasible solution). For example: <em>Unless there is no other way</em>, a teacher cannot teach in a room that does not belong to his department.
In this case, the teacher should <em>not</em> be limited in his room value range (because sometimes there is no other way).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By limiting the value range specifically of one planning entity, you are effectively creating a <em>built-in hard constraint</em>.
This can have the benefit of severely lowering the number of possible solutions; however, it can also take away the freedom of the optimization algorithms to temporarily break that constraint in order to escape from a local optimum.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A planning entity should <em>not</em> use other planning entities to determine its value range.
That would only try to make the planning entity solve the planning problem itself and interfere with the optimization algorithms.</p>
</div>
<div class="paragraph">
<p>Every entity has its own <code>list</code> instance, unless multiple entities have the same value range.
For example, if teacher A and B belong to the same department, they use the same <code>list</code> instance.
Furthermore, each <code>list</code> contains a subset of the same set of planning value instances.
For example, if department A and B can both use room X, then their <code>list</code> instances contain the same <code>Room</code> instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A <code>@value_range_provider</code> on the planning entity consumes more memory than <code>@value_range_provider</code> on the Solution and disables certain automatic performance optimizations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A <code>@value_range_provider</code> on the planning entity is not currently compatible with a <a href="#chainedPlanningVariable">chained</a> variable.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="valueRangeFactory"><a class="anchor" href="#valueRangeFactory"></a><code>ValueRangeFactory</code></h5>
<div class="paragraph">
<p>Instead of a <code>Collection</code>, you can also return a <code>ValueRange</code> or <code>CountableValueRange</code>, built by the <code>ValueRangeFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution, value_range_provider
from optapy.types import CountableValueRange, ValueRangeFactory

    @value_range_provider(range_id = "delay_range", value_range_type = CountableValueRange)
    def get_delay_range(self):
        return ValueRangeFactory.createIntValueRange(0, 5000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ValueRange</code> uses far less memory, because it only holds the bounds.
In the example above, a <code>list</code> would need to hold all <code>5000</code> ints, instead of just the two bounds.</p>
</div>
<div class="paragraph">
<p>Furthermore, an <code>incrementUnit</code> can be specified, for example if you have to buy stocks in units of 200 pieces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution, value_range_provider
from optapy.types import CountableValueRange, ValueRangeFactory

    @value_range_provider(range_id = "stock_amount_range", value_range_type = CountableValueRange)
    def get_stock_amount_range(self) {
        # Range: 0, 200, 400, 600, ..., 9999600, 9999800, 10000000
        return ValueRangeFactory.createIntValueRange(0, 10000000, 200);
    }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Return <code>CountableValueRange</code> instead of <code>ValueRange</code> whenever possible (so OptaPy knows that it&#8217;s countable).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ValueRangeFactory</code> has creation methods for several value class types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean</code>: A boolean range.</p>
</li>
<li>
<p><code>int</code>: A 32bit integer range.</p>
</li>
<li>
<p><code>long</code>: A 64bit integer range.</p>
</li>
<li>
<p><code>double</code>: A 64bit floating point range which only supports random selection (because it does not implement <code>CountableValueRange</code>).</p>
</li>
<li>
<p><code>BigInteger</code>: An arbitrary-precision integer range.</p>
</li>
<li>
<p><code>BigDecimal</code>: A decimal point range. By default, the increment unit is the lowest non-zero value in the scale of the bounds.</p>
</li>
<li>
<p><code>Temporal</code> (such as <code>LocalDate</code>, <code>LocalDateTime</code>, &#8230;&#8203;): A time range.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="combineValueRangeProviders"><a class="anchor" href="#combineValueRangeProviders"></a>Combine <code>ValueRangeProviders</code></h5>
<div class="paragraph">
<p>Value range providers can be combined, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    @planning_variable(value_range_provider_refs = ["company_car_range", "personal_car_range"])
    def get_car(self):
        return self.car
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    @value_range_provider(id = "company_car_range")
    def get_company_car_list(self):
        return self.company_car_list

    @value_range_provider(id = "personal_car_range")
    def get_personal_car_list(self):
        return self.personal_car_list</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="planningValueStrength"><a class="anchor" href="#planningValueStrength"></a>3.4.6. Planning value strength</h4>
<div class="paragraph">
<p>Planning value difficulty is not yet supported, but will be in a future version.</p>
</div>
</div>
<div class="sect3">
<h4 id="planningListVariables"><a class="anchor" href="#planningListVariables"></a>3.4.7. Planning List Variable</h4>
<div class="paragraph">
<p>In some use cases, such as Vehicle Routing and Task Assignment, it is more convenient to model the planning variables as a list.
For example, the list of customers a vehicle visits, or the list of tasks a person does.
In OptaPy, this is accomplished by using planning list variables.</p>
</div>
<div class="paragraph">
<p>For a planning list variable with value range "value_range":</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The order of elements inside the list is significant</p>
</li>
<li>
<p>All values in "value_range" appear in exactly one planning
entity&#8217;s planning list variable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To declare a planning list variable, use the <code>@planning_list_variable</code> decorator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_entity, planning_list_variable

@planning_entity
class Vehicle:
    def __init__(self, _id, capacity, depot, customer_list=None):
        self.id = _id
        self.capacity = capacity
        self.depot = depot
        if customer_list is None:
            self.customer_list = []
        else:
            self.customer_list = customer_list

    @planning_list_variable(Customer, ['customer_range'])
    def get_customer_list(self):
        return self.customer_list

    ...</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The getter for <code>@planning_list_variable</code> can never return None.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="chainedPlanningVariable"><a class="anchor" href="#chainedPlanningVariable"></a>3.4.8. Chained planning variable (TSP, VRP, &#8230;&#8203;)</h4>
<div class="paragraph">
<p>Some use cases, such as TSP and Vehicle Routing, require <em>chaining</em>.
This means the planning entities point to each other and form a chain.
By modeling the problem as a set of chains (instead of a set of trees/loops), the search space is heavily reduced.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#planningListVariables">Planning list variables</a> can also be used for these use cases</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A planning variable that is chained either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Directly points to a problem fact (or planning entity), which is called an <em>anchor</em>.</p>
</li>
<li>
<p>Points to another planning entity with the same planning variable, which recursively points to an anchor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are some examples of valid and invalid chains:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/planner-configuration/chainPrinciples.png" alt="chainPrinciples">
</div>
</div>
<div class="paragraph">
<p><strong>Every initialized planning entity is part of an open-ended chain that begins from an anchor.</strong> A valid model means that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A chain is never a loop. The tail is always open.</p>
</li>
<li>
<p>Every chain always has exactly one anchor. The anchor is never an instance of the planning entity class that contains the chained planning variable.</p>
</li>
<li>
<p>A chain is never a tree, it is always a line. Every anchor or planning entity has at most one trailing planning entity.</p>
</li>
<li>
<p>Every initialized planning entity is part of a chain.</p>
</li>
<li>
<p>An anchor with no planning entities pointing to it, is also considered a chain.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A planning problem instance given to the <code>Solver</code> must be valid.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If your constraints dictate a closed chain, model it as an open-ended chain (which is easier to persist in a database) and implement a score constraint for the last entity back to the anchor.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The optimization algorithms and built-in <code>Move</code>s do chain correction to guarantee that the model stays valid:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/planner-configuration/chainCorrection.png" alt="chainCorrection">
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A custom <code>Move</code> implementation must leave the model in a valid state.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, in TSP the anchor is a <code>Domicile</code> (in vehicle routing it is <code>Vehicle</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import problem_fact, planning_entity, planning_variable
from optapy.types import PlanningVariableGraphType

@problem_fact
class Standstill:
    def get_city(self):
        raise NotImplementedError()


@problem_fact
class Domicile(Standstill):
    # ...
    def get_city(self):
        return self.city


@planning_entity
class Visit(Standstill):
    # ...
    @planning_variable(Standstill, value_range_provider_refs=['domicile_range', 'visit_range'],
                              graph_type=PlanningVariableGraphType.CHAINED)
    def get_previous_standstill(self):
        return self.previous_standstill

    def set_previous_standstill(self, previous_standstill):
        self.previous_standstill = previous_standstill</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how two value range providers are usually combined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The value range provider that holds the anchors, for example <code>domicile_list</code>.</p>
</li>
<li>
<p>The value range provider that holds the initialized planning entities, for example <code>visit_list</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="planningProblemAndPlanningSolution"><a class="anchor" href="#planningProblemAndPlanningSolution"></a>3.5. Planning problem and planning solution</h3>
<div class="sect3">
<h4 id="planningProblemInstance"><a class="anchor" href="#planningProblemInstance"></a>3.5.1. Planning problem instance</h4>
<div class="paragraph">
<p>A dataset for a planning problem needs to be wrapped in a class for the <code>Solver</code> to solve.
That solution class represents both the planning problem and (if solved) a solution.
It is decorated with a <code>@planning_solution</code> decorator.
For example in n queens, the solution class is the <code>NQueens</code> class, which contains a <code>Column</code> list, a <code>Row</code> list, and a <code>Queen</code> list.</p>
</div>
<div class="paragraph">
<p>A planning problem is actually an unsolved planning solution or - stated differently - an uninitialized solution.
For example in n queens, that <code>NQueens</code> class has the <code>@planning_solution</code> annotation, yet every <code>Queen</code> in an unsolved <code>NQueens</code> class is not yet assigned to a <code>Row</code> (their <code>row</code> property is <code>null</code>). That&#8217;s not a feasible solution.
It&#8217;s not even a possible solution.
It&#8217;s an uninitialized solution.</p>
</div>
</div>
<div class="sect3">
<h4 id="solutionClass"><a class="anchor" href="#solutionClass"></a>3.5.2. Solution class</h4>
<div class="paragraph">
<p>A solution class holds all problem facts, planning entities and a score.
It is annotated with a <code>@PlanningSolution</code> annotation.
For example, an <code>NQueens</code> instance holds a list of all columns, all rows and all <code>Queen</code> instances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution
from optapy.score import SimpleScore

@planning_solution
class NQueens:
    # Problem facts
    n: int
    column_list: list[Column]
    row_list: list[Row]

    # Planning entities
    queen_list: list[Queen]

    score: SimpleScore
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solver configuration needs to declare the planning solution class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  ...
  &lt;solutionClass&gt;optapy.examples.domain.NQueens&lt;/solutionClass&gt;
  ...
&lt;/solver&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="planningEntitiesOfASolution"><a class="anchor" href="#planningEntitiesOfASolution"></a>3.5.3. Planning entities of a solution (<code>@planning_entity_collection_property</code>)</h4>
<div class="paragraph">
<p>OptaPy needs to extract the entity instances from the solution instance.
It gets those collection(s) by calling every getter that is annotated with <code>@planning_entity_collection_property</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution, planning_entity_collection_property

@planning_solution
class NQueens :
    # ...
    queen_list: list[Queen]

    @planning_entity_collection_property(Queen)
    def get_queen_list(self):
        return self.queen_list</code></pre>
</div>
</div>
<div class="paragraph">
<p>There can be multiple <code>@planning_entity_collection_property</code> decorated getters.
Those can even return a list with the same entity class type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A <code>@planning_entity_collection_property</code> annotation needs to be on a getter in a class with a <code>@planning_solution</code> decorator.
It is ignored on parent classes or subclasses without that decorator.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In rare cases, a planning entity might be a singleton: use <code>planning_entity_property</code> on its getter instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="scoreOfASolution"><a class="anchor" href="#scoreOfASolution"></a>3.5.4. <code>Score</code> of a Solution (<code>@PlanningScore</code>)</h4>
<div class="paragraph">
<p>A <code>@planning_solution</code> class requires a score property (or field), which is annotated with a <code>@planning_score</code> annotation.
The score property is <code>None</code> if the score hasn&#8217;t been calculated yet.
The <code>score</code> property is typed to the specific <code>Score</code> implementation of your use case.
For example, <code>NQueens</code> uses a <a href="../score-calculation/score-calculation.html#simpleScore" class="xref page">SimpleScore</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution, planning_score
from optapy.score import SimpleScore

@planning_solution
class NQueens:
    # ...
    score: SimpleScore

    @planning_score(SimpleScore)
    def get_score(self):
        return self.score

    def set_score(self, score):
        self.score = score</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most use cases use a <a href="../score-calculation/score-calculation.html#hardSoftScore" class="xref page">HardSoftScore</a> instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">@planning_solution
class CloudBalance:
    # ...
    score: HardSoftScore

    @planning_score(HardSoftScore)
    def get_score(self):
        return self.score

    def set_score(self, score):
        self.score = score</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some use cases use <a href="../score-calculation/score-calculation.html#scoreType" class="xref page">other score types</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="problemFacts"><a class="anchor" href="#problemFacts"></a>3.5.5. Problem facts of a solution (<code>@problem_fact_collection_property</code>)</h4>
<div class="paragraph">
<p>For <a href="../constraint-streams/constraint-streams.html#constraintStreams" class="xref page">Constraint Streams score calculation</a>,
OptaPlanner needs to extract the problem fact instances from the solution instance.
It gets those collection(s) by calling every method (or field) that is annotated with <code>@problem_fact_collection_property</code>.
All objects returned by those methods are available to use by Constraint Streams.
For example in <code>NQueens</code> all <code>Column</code> and <code>Row</code> instances are problem facts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import planning_solution, problem_fact_collection_property

@planning_solution
class NQueens:
    # ...

    column_list: list[Column]
    row_list: list[Row]

    @problem_fact_collection_property(Column)
    def get_column_list(self):
        return self.column_list

    @problem_fact_collection_property(Row)
    def get_row_list(self):
        return self.row_list</code></pre>
</div>
</div>
<div class="paragraph">
<p>All planning entities are automatically inserted into the working memory.
Do not add <code>@problem_fact_collection_property</code> on their properties.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The problem facts methods are not called often: at most only once per solver phase per solver thread.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There can be multiple <code>@problem_fact_collection_property</code> annotated members.
Those can even return a <code>list</code> with the same class type, but they shouldn&#8217;t return the same instance twice.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A <code>@problem_fact_collection_property</code>  annotation needs to be on a member in a class with a <code>@planning_solution</code> annotation.
It is ignored on parent classes or subclasses without that annotation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In rare cases, a problem fact might be a singleton: use <code>@problem_fact_property</code> on its method instead.</p>
</div>
<div class="sect4">
<h5 id="cachedProblemFact"><a class="anchor" href="#cachedProblemFact"></a>Cached problem fact</h5>
<div class="paragraph">
<p>A cached problem fact is a problem fact that does not exist in the real domain model, but is calculated before the <code>Solver</code> really starts solving.
The problem facts methods have the opportunity to enrich the domain model with such cached problem facts, which can lead to simpler and faster score constraints.</p>
</div>
<div class="paragraph">
<p>For example in examination, a cached problem fact <code>TopicConflict</code> is created for every two <code>Topic</code>s which share at least one <code>Student</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    @problem_fact_collection_property(TopicConflict)
    def calculate_topic_conflict_list(self): list[TopicConflict]:
        topic_conflict_list = []
        for left_topic in self.topic_list:
            for right_topic in self.topic_list:
                if left_topic.topic_id &lt; right_topic.topic_id:
                    student_size = 0;
                    for student in left_topic.student_list:
                        if student in right_topic.student_list:
                            student_size += 1
                    if student_size &gt; 0:
                        topic_conflict_list.append(TopicConflict(left_topic, right_topic, student_size))
        return topic_conflict_list;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where a score constraint needs to check that no two exams with a topic that shares a student are scheduled close together (depending on the constraint: at the same time, in a row, or in the same day), the <code>TopicConflict</code> instance can be used as a problem fact, rather than having to combine every two <code>Student</code> instances.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cloningASolution"><a class="anchor" href="#cloningASolution"></a>3.5.6. Cloning a solution</h4>
<div class="paragraph">
<p>Most (if not all) optimization algorithms clone the solution each time they encounter a new best solution (so they can recall it later) or to work with multiple solutions in parallel.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are many ways to clone, such as a shallow clone, deep clone, &#8230;&#8203; This context focuses on <em>a planning clone</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A planning clone of a solution must fulfill these requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The clone must represent the same planning problem. Usually it reuses the same instances of the problem facts and problem fact collections as the original.</p>
</li>
<li>
<p>The clone must use different, cloned instances of the entities and entity collections.
Changes to an original solution entity&#8217;s variables must not affect its clone.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../_images/planner-configuration/solutionCloning.png" alt="solutionCloning">
</div>
</div>
<div class="paragraph">
<p><strong>Implementing a planning clone method is hard, therefore you do not need to implement it.</strong></p>
</div>
<div class="sect4">
<h5 id="fieldAccessingSolutionCloner"><a class="anchor" href="#fieldAccessingSolutionCloner"></a><code>FieldAccessingSolutionCloner</code></h5>
<div class="paragraph">
<p>This <code>SolutionCloner</code> is used by default.
It works well for most use cases.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the <code>FieldAccessingSolutionCloner</code> clones one of your collections or maps,
it may not recognize the implementation and replace it with <code>list</code>, <code>set</code> or <code>map</code> (whichever is more applicable).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>FieldAccessingSolutionCloner</code> does not clone problem facts by default.
If any of your problem facts needs to be deep cloned for a planning clone,
for example if the problem fact references a planning entity or the planning solution,
mark its class with a <code>@deep_planning_clone</code> decorator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import problem_fact, deep_planning_clone

@problem_fact
@deep_planning_clone
class SeatDesignationDependency:
    left_seat_designation: SeatDesignation # planning entity
    right_seat_designation: SeatDesignation # planning entity
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, because <code>SeatDesignationDependency</code> references the planning entity <code>SeatDesignation</code>
(which is deep planning cloned automatically), it should also be deep planning cloned.</p>
</div>
<div class="paragraph">
<p>Alternatively, the <code>@deep_planning_clone</code> decorator also works on a getter method to planning clone it.
If that property is a <code>list</code> or a <code>map</code>, it will shallow clone it and deep planning clone
any element thereof that is an instance of a class that has a <code>@deep_planning_clone</code> decorator.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="createAnUninitializedSolution"><a class="anchor" href="#createAnUninitializedSolution"></a>3.5.7. Create an uninitialized solution</h4>
<div class="paragraph">
<p>Create a <code>@planning_solution</code> class instance to represent your planning problem&#8217;s dataset, so it can be set on the <code>Solver</code> as the planning problem to solve.
For example in n queens, an <code>NQueens</code> instance is created with the required <code>Column</code> and <code>Row</code> instances and every <code>Queen</code> set to a different <code>column</code> and every <code>row</code> set to <code>null</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">    def create_n_queens(n: int) -&gt; NQueens:
        n_queens = NQueens()
        n_queens.n = n
        n_queens.column_list = create_column_list(n_queens)
        n_queens.row_list = create_row_list(n_queens)
        n_queens.queen_list = create_queen_list(n_queens)
        return n_queens

    def create_queen_list(n_queens: NQueens) -&gt; list[Queen]:
        n = n_queens.n
        queen_list = []
        queen_id = 0
        for column in n_queens.column_list:
            queen = Queen()
            queen.queen_id = id
            queen_id += 1
            queen.column = column;
            # Notice that we leave the PlanningVariable properties as None
            queen_list.append(queen);
        return queen_list;</code></pre>
</div>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../_images/planner-configuration/uninitializedNQueens04.png" alt="uninitializedNQueens04">
</div>
<div class="title">Figure 1. Uninitialized Solution for the Four Queens Puzzle</div>
</div>
<div class="paragraph">
<p>Usually, most of this data comes from your data layer, and your solution implementation just aggregates that data and creates the uninitialized planning entity instances to plan:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">def create_lecture_list(schedule: CourseSchedule):
    course_list = schedule.course_list
    lecture_list = []
    lecture_id = 0
    for course in course_list:
        for i in range(course.lecture_size):
            lecture = Lecture()
            lecture.lecture_id = lecture_id
            lecture_id += 1
            lecture.course = course
            lecture.lecture_index_in_course = i
            # Notice that we leave the PlanningVariable properties (period and room) as None
            lecture_list.append(lecture)
    schedule.lecture_list = lecture_list</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="useTheSolver"><a class="anchor" href="#useTheSolver"></a>4. Use the <code>Solver</code></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="theSolverInterface"><a class="anchor" href="#theSolverInterface"></a>4.1. The <code>Solver</code> interface</h3>
<div class="paragraph">
<p>A <code>Solver</code> solves your planning problem.</p>
</div>
<div class="paragraph">
<p>A <code>Solver</code> can only solve one planning problem instance at a time.
It is built with a <code>SolverFactory</code>, there is no need to implement it yourself.</p>
</div>
<div class="paragraph">
<p>A <code>Solver</code> should only be accessed from a single thread, except for the methods that are specifically documented in javadoc as being thread-safe.
The <code>solve()</code> method hogs the current thread.
This can cause HTTP timeouts for REST services and it requires extra code to solve multiple datasets in parallel.
To avoid such issues, use a <a href="#solverManager"><code>SolverManager</code></a> instead.</p>
</div>
</div>
<div class="sect2">
<h3 id="solvingAProblem"><a class="anchor" href="#solvingAProblem"></a>4.2. Solving a problem</h3>
<div class="paragraph">
<p>Solving a problem is quite easy once you have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>Solver</code> built from a solver configuration</p>
</li>
<li>
<p>A <code>@planning_solution</code> that represents the planning problem instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Just provide the planning problem as argument to the <code>solve()</code> method and it will return the best solution found:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">problem = ...
best_solution = solver.solve(problem)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example in n queens, the <code>solve()</code> method will return an <code>NQueens</code> instance with every <code>Queen</code> assigned to a <code>Row</code>.</p>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../_images/planner-configuration/solvedNQueens04.png" alt="solvedNQueens04">
</div>
<div class="title">Figure 2. Best Solution for the Four Queens Puzzle in 8ms (Also an Optimal Solution)</div>
</div>
<div class="paragraph">
<p>The <code>solve(Solution)</code> method can take a long time (depending on the problem size and the solver configuration). The <code>Solver</code> intelligently wades through <a href="../optimization-algorithms/optimization-algorithms.html#searchSpaceSize" class="xref page">the search space</a> of possible solutions and remembers the best solution it encounters during solving.
Depending on a number of factors (including problem size, how much time the <code>Solver</code> has, the solver configuration, &#8230;&#8203;), <a href="../optimization-algorithms/optimization-algorithms.html#doesPlannerFindTheOptimalSolution" class="xref page">that best solution might or might not be an optimal solution</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The solution instance given to the method <code>solve(solution)</code> is changed by the <code>Solver</code>,
but do not mistake it for the best solution.</p>
</div>
<div class="paragraph">
<p>The solution instance returned by the methods <code>solve(solution)</code> or <code>getBestSolution()</code> is most likely <a href="#cloningASolution">a planning clone</a> of the instance given to the method <code>solve(solution)</code>, which implies it is a different instance.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The solution instance given to the <code>solve(Solution)</code> method does not need to be uninitialized.
It can be partially or fully initialized, which is often the case in <a href="../repeated-planning/repeated-planning.html#repeatedPlanning" class="xref page">repeated planning</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="environmentMode"><a class="anchor" href="#environmentMode"></a>4.3. Environment mode: are there bugs in my code?</h3>
<div class="paragraph">
<p>The environment mode allows you to detect common bugs in your implementation.
It does not affect the <a href="#logging">logging level</a>.</p>
</div>
<div class="paragraph">
<p>You can set the environment mode in the solver configuration XML file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  &lt;environmentMode&gt;FAST_ASSERT&lt;/environmentMode&gt;
  ...
&lt;/solver&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A solver has a single <code>Random</code> instance.
Some solver configurations use the <code>Random</code> instance a lot more than others.
For example, Simulated Annealing depends highly on random numbers, while Tabu Search only depends on it to deal with score ties.
The environment mode influences the seed of that <code>Random</code> instance.</p>
</div>
<div class="paragraph">
<p>These are the environment modes:</p>
</div>
<div class="sect3">
<h4 id="environmentModeFullAssert"><a class="anchor" href="#environmentModeFullAssert"></a>4.3.1. <code>FULL_ASSERT</code></h4>
<div class="paragraph">
<p>The FULL_ASSERT mode turns on all assertions (such as assert that the incremental score calculation is uncorrupted for each move) to fail-fast on a bug in a Move implementation, a constraint, the engine itself, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>This mode is reproducible (see the reproducible mode). It is also intrusive because it calls the method <code>calculateScore()</code> more frequently than a non-assert mode.</p>
</div>
<div class="paragraph">
<p>The FULL_ASSERT mode is horribly slow (because it does not rely on incremental score calculation).</p>
</div>
</div>
<div class="sect3">
<h4 id="environmentModeNonIntrusiveFullAssert"><a class="anchor" href="#environmentModeNonIntrusiveFullAssert"></a>4.3.2. <code>NON_INTRUSIVE_FULL_ASSERT</code></h4>
<div class="paragraph">
<p>The NON_INTRUSIVE_FULL_ASSERT turns on several assertions to fail-fast on a bug in a Move implementation, a constraint, the engine itself, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>This mode is reproducible (see the reproducible mode). It is non-intrusive because it does not call the method <code>calculateScore()</code> more frequently than a non assert mode.</p>
</div>
<div class="paragraph">
<p>The NON_INTRUSIVE_FULL_ASSERT mode is horribly slow (because it does not rely on incremental score calculation).</p>
</div>
</div>
<div class="sect3">
<h4 id="environmentModeFastAssert"><a class="anchor" href="#environmentModeFastAssert"></a>4.3.3. <code>FAST_ASSERT</code></h4>
<div class="paragraph">
<p>The FAST_ASSERT mode turns on most assertions (such as assert that an undoMove&#8217;s score is the same as before the Move) to fail-fast on a bug in a Move implementation, a constraint, the engine itself, &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>This mode is reproducible (see the reproducible mode). It is also intrusive because it calls the method <code>calculateScore()</code> more frequently than a non assert mode.</p>
</div>
<div class="paragraph">
<p>The FAST_ASSERT mode is slow.</p>
</div>
<div class="paragraph">
<p>It is recommended to write a test case that does a short run of your planning problem with the FAST_ASSERT mode on.</p>
</div>
</div>
<div class="sect3">
<h4 id="environmentModeReproducible"><a class="anchor" href="#environmentModeReproducible"></a>4.3.4. <code>REPRODUCIBLE</code> (default)</h4>
<div class="paragraph">
<p>The reproducible mode is the default mode because it is recommended during development.
In this mode, two runs in the same OptaPlanner version will execute the same code in the same order. <strong>Those two
runs will have the same result at every step</strong>, except if the note below applies.
This enables you to reproduce bugs consistently.
It also allows you to benchmark certain refactorings (such as a score constraint performance optimization) fairly across runs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Despite the reproducible mode, your application might still not be fully reproducible because of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use of <code>set</code> (or another <code>Collection</code> which has an inconsistent order between Python runs) for collections of planning entities or planning values (but not normal problem facts), especially in the solution implementation.</p>
</li>
<li>
<p>Combining a time gradient dependent algorithms (most notably Simulated Annealing) together with time spent termination. A sufficiently large difference in allocated CPU time will influence the time gradient values. Replace Simulated Annealing with Late Acceptance. Or instead, replace time spent termination with step count termination.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The reproducible mode can be slightly slower than the non-reproducible mode.
If your production environment can benefit from reproducibility, use this mode in production.</p>
</div>
<div class="paragraph">
<p>In practice, this mode uses the default, fixed <a href="#randomNumberGenerator">random seed</a> if no seed is specified, and it also disables certain concurrency optimizations (such as work stealing).</p>
</div>
</div>
<div class="sect3">
<h4 id="environmentModeProduction"><a class="anchor" href="#environmentModeProduction"></a>4.3.5. <code>NON_REPRODUCIBLE</code></h4>
<div class="paragraph">
<p>The non-reproducible mode can be slightly faster than the reproducible mode.
Avoid using it during development as it makes debugging and bug fixing painful.
If your production environment doesn&#8217;t care about reproducibility, use this mode in production.</p>
</div>
<div class="paragraph">
<p>In practice, this mode uses no fixed <a href="#randomNumberGenerator">random seed</a> if no seed is specified.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logging"><a class="anchor" href="#logging"></a>4.4. Logging level: what is the <code>Solver</code> doing?</h3>
<div class="paragraph">
<p>The best way to illuminate the black box that is a <code>Solver</code>, is to play with the logging level:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>error</strong>: Log errors, except those that are thrown to the calling code as a <code>RuntimeException</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>If an error happens, OptaPy normally fails fast.</strong>
It does not log it as an error itself to avoid duplicate log messages.
Meanwhile, the code is disrupted from doing further harm or obfuscating the error.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><strong>warn</strong>: Log suspicious circumstances.</p>
</li>
<li>
<p><strong>info</strong>: Log every phase and the solver itself. See <a href="../optimization-algorithms/optimization-algorithms.html#scopeOverview" class="xref page">scope overview</a>.</p>
</li>
<li>
<p><strong>debug</strong>: Log every step of every phase. See <a href="../optimization-algorithms/optimization-algorithms.html#scopeOverview" class="xref page">scope overview</a>.</p>
</li>
<li>
<p><strong>trace</strong>: Log every move of every step of every phase. See <a href="../optimization-algorithms/optimization-algorithms.html#scopeOverview" class="xref page">scope overview</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Turning on <code>trace</code> logging, will slow down performance considerably: it is often four times slower.
However, it is invaluable during development to discover a bottleneck.</p>
</div>
<div class="paragraph">
<p>Even <code>debug</code> logging can slow down performance considerably for fast stepping algorithms (such as Late Acceptance and Simulated Annealing),
but not for slow stepping algorithms (such as Tabu Search).</p>
</div>
<div class="paragraph">
<p>Both cause congestion in <a href="../optimization-algorithms/optimization-algorithms.html#multithreadedSolving" class="xref page">multithreaded solving</a> with most appenders, see below..</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, set it to <code>debug</code> logging, to see when the phases end and how fast steps are taken:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">INFO  Solving started: time spent (3), best score (-4init/0), random (JDK with seed 0).
DEBUG     CH step (0), time spent (5), score (-3init/0), selected move count (1), picked move (Queen-2 {null -&gt; Row-0}).
DEBUG     CH step (1), time spent (7), score (-2init/0), selected move count (3), picked move (Queen-1 {null -&gt; Row-2}).
DEBUG     CH step (2), time spent (10), score (-1init/0), selected move count (4), picked move (Queen-3 {null -&gt; Row-3}).
DEBUG     CH step (3), time spent (12), score (-1), selected move count (4), picked move (Queen-0 {null -&gt; Row-1}).
INFO  Construction Heuristic phase (0) ended: time spent (12), best score (-1), score calculation speed (9000/sec), step total (4).
DEBUG     LS step (0), time spent (19), score (-1),     best score (-1), accepted/selected move count (12/12), picked move (Queen-1 {Row-2 -&gt; Row-3}).
DEBUG     LS step (1), time spent (24), score (0), new best score (0), accepted/selected move count (9/12), picked move (Queen-3 {Row-3 -&gt; Row-2}).
INFO  Local Search phase (1) ended: time spent (24), best score (0), score calculation speed (4000/sec), step total (2).
INFO  Solving ended: time spent (24), best score (0), score calculation speed (7000/sec), phase total (2), environment mode (REPRODUCIBLE).</code></pre>
</div>
</div>
<div class="paragraph">
<p>All time spent values are in milliseconds.</p>
</div>
<div class="paragraph">
<p>Configure the logging level by explicitly calling <code>logging.getLogger('optapy').setLevel(logging.LEVEL)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">import logging

logging.getLogger('optapy').setLevel(logging.DEBUG)</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>INFO</code> logging is used.</p>
</div>
</div>
<div class="sect2">
<h3 id="monitoring"><a class="anchor" href="#monitoring"></a>4.5. Monitoring the solver</h3>
<div class="paragraph">
<p>OptaPy currently does not support metric export.</p>
</div>
</div>
<div class="sect2">
<h3 id="randomNumberGenerator"><a class="anchor" href="#randomNumberGenerator"></a>4.6. Random number generator</h3>
<div class="paragraph">
<p>Many heuristics and metaheuristics depend on a pseudorandom number generator for move selection, to resolve score ties, probability based move acceptance, &#8230;&#8203; During solving, the same <code>Random</code> instance is reused to improve reproducibility, performance and uniform distribution of random values.</p>
</div>
<div class="paragraph">
<p>To change the random seed of that <code>Random</code> instance, specify a <code>randomSeed</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  &lt;randomSeed&gt;0&lt;/randomSeed&gt;
  ...
&lt;/solver&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To change the pseudorandom number generator implementation, specify a <code>randomType</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;solver xmlns="https://www.optaplanner.org/xsd/solver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://www.optaplanner.org/xsd/solver https://www.optaplanner.org/xsd/solver/solver.xsd"&gt;
  &lt;randomType&gt;MERSENNE_TWISTER&lt;/randomType&gt;
  ...
&lt;/solver&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following types are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JDK</code> (default): Standard implementation (<code>java.util.Random</code>).</p>
</li>
<li>
<p><code>MERSENNE_TWISTER</code>: Implementation by <a href="http://commons.apache.org/proper/commons-math/userguide/random.html">Commons Math</a>.</p>
</li>
<li>
<p><code>WELL512A</code>, <code>WELL1024A</code>, <code>WELL19937A</code>, <code>WELL19937C</code>, <code>WELL44497A</code> and <code>WELL44497B</code>: Implementation by <a href="http://commons.apache.org/proper/commons-math/userguide/random.html">Commons Math</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solverManager"><a class="anchor" href="#solverManager"></a>5. SolverManager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <code>SolverManager</code> is a facade for one or more <code>Solver</code> instances
to simplify solving planning problems in REST and other enterprise services.
Unlike the <code>Solver.solve(&#8230;&#8203;)</code> method:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>SolverManager.solve(&#8230;&#8203;)</code> returns immediately</strong>: it schedules a problem for asynchronous solving without blocking the calling thread.
This avoids timeout issues of HTTP and other technologies.</p>
</li>
<li>
<p><strong><code>SolverManager.solve(&#8230;&#8203;)</code> solves multiple planning problems</strong> of the same domain, in parallel.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Internally a <code>SolverManager</code> manages a thread pool of solver threads, which call <code>Solver.solve(&#8230;&#8203;)</code>,
and a thread pool of consumer threads, which handle best solution changed events.</p>
</div>
<div class="paragraph">
<p>Build a <code>SolverManager</code> instance with the <code>solver_manager_create(&#8230;&#8203;)</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy import solver_manager_create, solver_config_create_from_xml_file
from optapy.types import Duration

solver_config = solver_config_create_from_xml_file("solverConfig.xml")
solver_manager = solver_manager_create(solver_config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each problem submitted to the <code>SolverManager.solve(&#8230;&#8203;)</code> methods needs a unique problem ID.
Later calls to <code>getSolverStatus(problemId)</code> or <code>terminateEarly(problemId)</code> use that problem ID
to distinguish between the planning problems.
The problem ID must be an immutable class, such as <code>int</code>, <code>str</code> or <code>uuid</code>.</p>
</div>
<div class="paragraph">
<p>To retrieve the best solution, after solving terminates normally, use <code>SolverJob.getFinalBestSolution()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">import uuid

problem1 = ...
problem_id = uuid.uuid4()
# Returns immediately
solver_job = solver_manager.solve(problem_id, problem1)
...
solution1 = solver_job.getFinalBestSolution()</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, there are better approaches, both for solving batch problems before an end-user needs the solution
as well as for live solving while an end-user is actively waiting for the solution, as explained below.</p>
</div>
<div class="paragraph">
<p>The current <code>SolverManager</code> implementation runs on a single computer node,
but future work aims to distribute solver loads across a cloud.</p>
</div>
<div class="sect2">
<h3 id="solverManagerSolveBatch"><a class="anchor" href="#solverManagerSolveBatch"></a>5.1. Solve batch problems</h3>
<div class="paragraph">
<p>At night, batch solving is a great approach to deliver solid plans by breakfast, because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are typically few or no problem changes in the middle of the night.
Some organizations even enforce a deadline, for example, <em>submit all day off requests before midnight</em>.</p>
</li>
<li>
<p>The solvers can run for much longer, often hours, because nobody&#8217;s waiting for it and CPU resources are often cheaper.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To solve a multiple datasets in parallel (limited by <code>parallelSolverCount</code>),
call <code>solve(&#8230;&#8203;)</code> for each dataset:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy.types import SolverManager

class TimeTableService:
    solver_manager: SolverManager

    # Returns immediately, call it for every dataset
    def solve_batch(self, time_table_id: int):
        solver_manager.solve(time_table_id,
                # Called once, when solving starts
                lambda the_id: self.find_by_id(the_id),
                # Called once, when solving ends
                lambda solution: self.save(solution))

    def find_by_id(self, time_table_id: int) -&gt; TimeTable:
        ...

    def save(self, time_table: TimeTable) -&gt; None:
        ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>A solid plan delivered by breakfast is great,
even if you need to react on problem changes during the day.</p>
</div>
</div>
<div class="sect2">
<h3 id="solverManagerSolveAndListen"><a class="anchor" href="#solverManagerSolveAndListen"></a>5.2. Solve and listen to show progress to the end-user</h3>
<div class="paragraph">
<p>When a solver is running while an end-user is waiting for that solution,
the user might need to wait for several minutes or hours before receiving a result.
To assure the user that everything is going well,
show progress by displaying the best solution and best score attained so far.</p>
</div>
<div class="paragraph">
<p>To handle intermediate best solutions, use <code>solveAndListen(&#8230;&#8203;)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-python hljs" data-lang="python">from optapy.types import SolverManager

class TimeTableService:
    solver_manager: SolverManager

    # Returns immediately
    def solve_live(self, time_table_id: int) -&gt; None:
        solver_manager.solveAndListen(time_table_id,
                # Called once, when solving starts
                lambda the_id: self.find_by_id(time_table_id),
                # Called multiple times, for every best solution change
                lambda solution: self.save(solution))

    def find_by_id(self, time_table_id: int):
        ...

    def save(self, time_table: TimeTable) -&gt; None:
        ...

    def stop_solving(self, time_table_id: int):
        solver_manager.terminateEarly(time_table_id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This implementation is using the database to communicate with the UI, which polls the database.
More advanced implementations push the best solutions directly to the UI or a messaging queue.</p>
</div>
<div class="paragraph">
<p>If the user is satisfied with the intermediate best solution
and does not want to wait any longer for a better one, call <code>SolverManager.terminateEarly(problemId)</code>.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>

<!-- Adobe Analytics for Red Hat - DPAL (DTM Property Auto-Loader) - part 2/2 -->
<script type="text/javascript">
    if (("undefined" !== typeof _satellite) && ("function" === typeof _satellite.pageBottom)) {
        _satellite.pageBottom();
    }
</script>  </body>
</html>
